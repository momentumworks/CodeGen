// MARK: - JSONEncodable

extension ASemiComplexEnum: JSONEncodable {

  private var typeString: String {
    switch self {
      case .Dell:  return "dell"
      case .Bell:  return "bell"
      case .Silicon:  return "silicon"
    }
  }

  static func fromJSON(optionalJSON: JSON?) -> ASemiComplexEnum? {
    guard let json = optionalJSON,
      type = json["type"].string,
      values = json["values"].array
    else {
      return logErrorAndReturnNil(optionalJSON)
    }

    switch (type) {
    case "dell":
      guard let value0 = values[0].string else {
        return logErrorAndReturnNil(optionalJSON)
      }
      return .Dell(value0)
    case "bell":
      guard let value0 = NumberType.fromJSON(values[0]) else {
        return logErrorAndReturnNil(optionalJSON)
      }
      return .Bell(value0)
    case "silicon":
      guard let value0 = values[0].int else {
        return logErrorAndReturnNil(optionalJSON)
      }
      return .Silicon(value0)
    default:
      return logErrorAndReturnNil(optionalJSON)
    }

  }

  func toJSON() -> JSON {
    var json = JSON([:])
    json["type"] = JSON(self.typeString)
    switch self {
    case .Dell(let value0):
      json["values"] = JSON([JSON(value0)])
    case .Bell(let value0):
      json["values"] = JSON([value0.toJSON()])
    case .Silicon(let value0):
      json["values"] = JSON([JSON(value0)])
    }
    return json
  }

}



extension NumberType: JSONEncodable {

  static func fromJSON(optionalJSON: JSON?) -> NumberType? {
    return optionalJSON?.string.flatMap { NumberType(rawValue: $0.lowercaseString) }
  }

  func toJSON() -> JSON {
    return JSON(self.rawValue.lowercaseString)
  }

}


